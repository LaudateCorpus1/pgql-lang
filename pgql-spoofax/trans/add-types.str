module add-types

imports

  stratego/-
  libspoofax/properties/-
  libspoofax/nabl/-
  libspoofax/task/-
  libspoofax/types/-
  signatures/-
  normalized-signatures
  common

rules

  annotate-with-types = bottomup(try(add-value-type-to-prop-and-var-ref)); bottomup(try(add-value-type))

  add-value-type-to-prop-and-var-ref:
    query@NormalizedQuery(_, _, _, Some(GraphPattern(Vertices(vertices), edges, Constraints(constraints))), _, _, _, _, _, _, _) -> query''
    with vertexDefinititions := <map(?Vertex(_, <id>, _))> vertices
       ; edgeDefinititions := <map(?Edge(_, _, _, _, <id>, _))> edges
       ; query' := <alltd(add-value-type-to-prop-ref(|vertexDefinititions, Vertex(), constraints) + add-value-type-to-prop-ref(|edgeDefinititions, Edge(), constraints))> query
       ; query'' := <alltd(add-value-type-to-var-ref(|vertexDefinititions, Vertex()) + add-value-type-to-var-ref(|edgeDefinititions, Edge()))> query'

  add-value-type-to-prop-ref(|varDefinitionOriginPositions, elemType, constraints):
    exp@PropRef(VarRef(_, varRefOriginPosition), Identifier(propName, _)) -> ExpressionPlusType(exp, type)
    where <elem> (varRefOriginPosition, varDefinitionOriginPositions)
    with labelExpression := <filter(simplify-label-expression(|varRefOriginPosition)); (?[]; !All() <+ to-label-conjunction)> constraints
       ; type := <get-property-type-from-label-expression(|elemType, propName)> labelExpression

  simplify-label-expression(|varRefOriginPosition):
    FunctionCall(None(), "has_label", [ VarRef(_, varRefOriginPosition), Identifier(label, _)]) -> label

  simplify-label-expression(|varRefOriginPosition):
    Or(a, b) -> LabelOr(a', b')
    where a' := <simplify-label-expression(|varRefOriginPosition)> a
        ; b' := <simplify-label-expression(|varRefOriginPosition)> b

  to-label-conjunction = reverse; !(<Tl>, <Hd>); foldl(to-label-AND)
  to-label-AND = ?(exp1, exp2); !LabelAnd(exp1, exp2)

  add-value-type-to-var-ref(|varDefinitionOriginPositions, elemType):
    exp@VarRef(_, varRefOriginPosition) -> ExpressionPlusType(exp, type)
    where <elem> (varRefOriginPosition, varDefinitionOriginPositions)
    with type := <?Vertex(); !Type("VERTEX") <+ !Type("EDGE")> elemType

//  add-type:
//    SetProperty(propRef, exp) -> SetProperty(propRef, <alltd(add-type)> exp) // this assures we skip adding a type to the propRef of a SET clause

//  add-value-type:
//    exp@PropRef(_, Identifier(propName, _), elementType, labelExpression) -> ExpressionPlusType(exp, type)
//    with type := <get-property-type-from-label-expression(|elementType, propName)> labelExpression

  get-property-type-from-label-expression(|elementType, propName):
    labelExpression -> type
    where <is-string> labelExpression
    with labelReference := labelExpression
       ; if <?Vertex()> elementType
         then type := <get-vertex-property-type> (labelReference, propName)
         else type := <get-edge-property-type> (labelReference, propName)
         end

  get-property-type-from-label-expression(|elementType, propName):
    LabelAnd(a, b) -> result
    with result := <compute-union-type(|elementType, propName)> (a, b)

  get-property-type-from-label-expression(|elementType, propName):
    LabelOr(a, b) -> result
    with result := <compute-union-type(|elementType, propName)> (a, b)

  compute-union-type(|elementType, propName):
    (labelA, labelB) -> result
    with typeA := <get-property-type-from-label-expression(|elementType, propName)> labelA
       ; typeB := <get-property-type-from-label-expression(|elementType, propName)> labelB
       ; result := <get-union-type> (typeA, typeB)

  get-property-type-from-label-expression(|elementType, propName):
    All() -> result
    with labels := <?Vertex(); get-vertex-labels <+ get-edge-labels> elementType
       ; types := <map(!(<id>, propName); get-vertex-property-type)> labels
       ; result := <foldl(get-union-type)> (types, Undefined())

  add-value-type = 
    ( ?And(_, _) + ?Or(_, _) +
      ?Mul(_, _) + ?Add(_, _) + ?Div(_, _) + ?Mod(_, _) + ?Sub(_, _) +
      ?Eq(_, _) + ?Neq(_, _) + ?Gt(_, _) + ?Lt(_, _) + ?Gte(_, _) + ?Lte(_, _) +
      ?Cct(_, _)
    )
    ; add-value-type-to-binary-operation

  is-boolean-expression = ?And(_, _) + ?Or(_, _) + ?Eq(_, _) + ?Neq(_, _) + ?Gt(_, _) + ?Lt(_, _) + ?Gte(_, _) + ?Lte(_, _)

  add-value-type-to-binary-operation:
    exp -> ExpressionPlusType(exp, type)
    with operation := <get-constructor> exp
       ; [ExpressionPlusType(_, type1), ExpressionPlusType(_, type2)] := <get-arguments> exp
       ; if <is-boolean-expression> exp
         then type := Type("BOOLEAN")
         else
           if <?AmbiguousType()> type1 + <?AmbiguousType()> type2
           then type := UnknownType()
           else if <?Type(t1)> type1;  <?Type(t2)> type2
                then type := <get-operation-return-type> (operation, t1, t2)
                else type := <?Type(_) <+ !type2; ?Type(_) <+ !UnknownType()> type1
                end
           end
         end

  get-operation-return-type = ?("Cct", "STRING", "STRING"); !Type("STRING")
  get-operation-return-type = ?("Add", "INTEGER", "INTEGER"); !Type("INTEGER")

  get-operation-return-type = !Undefined()

  get-vertex-labels = !["PERSON", "COMPANY"]

  get-edge-labels = !["KNOWS"]

  get-vertex-property-type = ?("PERSON", "FIRSTNAME"); !Type("STRING")
  get-vertex-property-type = ?("PERSON", "AGE"); !Type("INTEGER")
  get-vertex-property-type = ?("COMPANY", "AGE"); !Type("DATE")

  get-edge-property-type = ?("KNOWS", "SINCE"); !Type("DATE")

  get-vertex-property-type = !Undefined()

  get-edge-property-type = !Undefined()

  get-union-type = ?(Undefined(), <id>) + ?(<id>, Undefined())
  get-union-type = (?(AmbiguousType(), _) + ?(_, AmbiguousType())); !AmbiguousType()

  get-union-type = ?(Type("STRING"), Type("STRING")); !Type("STRING")

  get-union-type = ?(Type("INTEGER"), Type("INTEGER")); !Type("INTEGER")

  get-union-type = ?(Type("INTEGER"), Type("DATE"));  !AmbiguousType()
  get-union-type = ?(Type("DATE"), Type("INTEGER"));  !AmbiguousType()

signature constructors

  LabelOr            : STRING * STRING -> LabelOr

  LabelAnd           : STRING * STRING -> LabelAnd

  Vertex             : ElemType

  Edge               : ElemType

  ExpressionPlusType : Exp * Type -> ExpressionPlusType

  Type               : STRING -> Type

  Undefined          : Type // when the operation is undefined for the input types or the property does not exist 

  UnknownType        : Type

  AmbiguousType      : Type
