module check

imports

  stratego/-
  libspoofax/properties/-
  libspoofax/nabl/-
  libspoofax/task/-
  signatures/-
  normalized-signatures
  common
  names/-
  pp
  runtime/properties/-
  runtime/task/-
  add-types

rules // Unresolved/duplicate variables

  nabl-check-disable-unresolved = id
  nabl-check-disable-duplicate(|uri, ns) = id

  nabl-constraint(|ctx):
    query@NormalizedQuery(_, selectClause, _, matchClause, group-by, having, order-by, _, _, _, _) -> <fail>
    with unresolved-vars := <collect-in-outer-query(?VarRef(<id>))> query
        ; if None() := group-by
          then <batch-generate-error(|ctx, "Unresolved variable")> unresolved-vars
          else unresolved-vars-after-grouping := <collect-in-outer-query-outside-aggregation(?VarRef(<id>))> (selectClause, having, order-by)
             ; other-unresolved-vars := <diff> (unresolved-vars, unresolved-vars-after-grouping)
             ; <batch-generate-error(|ctx, "Unresolved variable")> other-unresolved-vars
             ; if CreateOneGroup() := group-by // aggregation without GROUP BY
               then <batch-generate-error(|ctx, "Unresolved variable (did you mean to use an aggregation?)")> unresolved-vars-after-grouping
               else <batch-generate-error(|ctx, "Unresolved variable (did you mean to use a group key?)")> unresolved-vars-after-grouping
               end
          end

  nabl-constraint(|ctx):
    NormalizedQuery(_, selectOrModifyClauseWithAnnos, _, graphPatternWithAnnos, groupClauseWithAnnos, _, _, _, _, _, _) -> <fail>
    with selectOrModifyClause := <strip-annos> selectOrModifyClauseWithAnnos
       ; graphPattern := <strip-annos> graphPatternWithAnnos
       ; groupClause := <strip-annos> groupClauseWithAnnos
       ; matchVars := <?None(); ![] <+ ?Some(GraphPattern(vertices, edges, _)); !(vertices, edges); collect(is-pattern-elem); collect-om(get-pattern-elem, conc)> graphPattern
       ; if <?Some(_)> groupClause
         then groupVars := <?Some(GroupByClause(<id>)); map(?ExpAsVar(_, Identifier(<id>, _), _, _))> groupClause
         else groupVars := []
         end
       ; <generate-error-on-duplicates(|ctx, "Duplicate variable")> matchVars
       ; <generate-error-on-duplicates(|ctx, "Duplicate column name in GROUP BY")> groupVars
       ; if <?SelectClause(_, _)> selectOrModifyClause
         then selectVars := <collect-om(?ExpAsVar(_, Identifier(<id>, _), _, _), conc)> selectOrModifyClause // for e.g. SELECT n.age, n.AgE
            ; duplicateSelectVarError := "Duplicate column name in SELECT"
            ; <generate-error-on-duplicates(|ctx, duplicateSelectVarError)> selectVars
            ; selectVarsOriginText := <collect-om(?ExpAsVar(_, Identifier(_, <id>), _, _), conc)> selectOrModifyClause // for e.g. SELECT n.age, n."age"
            ; <generate-error-on-duplicates(|ctx, duplicateSelectVarError)> selectVarsOriginText
            ; insertVars := []
         else // MODIFY query
              insertVars := <collect-om(?VertexInsertion(Identifier(<id>, _), _, _, _) + ?DirectedEdgeInsertion(Identifier(<id>, _), _, _, _, _, _), conc)> selectOrModifyClause
            ; <generate-error-on-duplicates(|ctx, "Duplicate variable in INSERT")> insertVars
            ; updateVars := <collect-om(?Update(VarRef(Identifier(<id>, _)), _) + ?Update(VarRef(Identifier(<id>, _), _), _), conc)> selectOrModifyClause
            ; updates-of-inserts := <isect> (updateVars, insertVars)
            ; <batch-generate-error(|ctx, "Cannot update an element that is being inserted")> updates-of-inserts
            ; deleteVars := <(collect-one(?DeleteClause(<id>)) <+ ![]); filter(?VarRef(Identifier(<id>, _), _))> selectOrModifyClause
            ; sourceVertices := <collect-om(?DirectedEdgeInsertion(_, _, VarRef(Identifier(<id>, _), _), _, _, _), conc)> selectOrModifyClause
            ; destinationVertices := <collect-om(?DirectedEdgeInsertion(_, _, _, VarRef(Identifier(<id>, _), _), _, _), conc)> selectOrModifyClause
            ; all-updateVars := <conc> (updateVars, sourceVertices, destinationVertices)
            ; deletes-of-updates := <isect> (all-updateVars, deleteVars)
            ; <batch-generate-error(|ctx, "Element is deleted in DELETE clause")> deletes-of-updates
         end

       ; if <?Some(_)> groupClause
         then nonAnonymousGroupVars := <?Some(GroupByClause(<id>)); filter(?ExpAsVar(_, Identifier(<id>, _), NonAnonymous(), _))> groupClause
         else nonAnonymousGroupVars := []
         end
       ; redefinitions-in-groupBy := <isect> (nonAnonymousGroupVars, matchVars)
       ; <batch-generate-error(|ctx, "Duplicate variable: variable already defined in the MATCH clause")> redefinitions-in-groupBy

       ; if <?None()> groupClause
         then redefinition-in-modify := <isect> (insertVars, matchVars)
            ; <batch-generate-error(|ctx, "Duplicate variable: variable already defined in the MATCH clause")> redefinition-in-modify
         else if <?ModifyClause(_)> selectOrModifyClause
              then redefinitions-in-modify := <isect> (insertVars, nonAnonymousGroupVars)
                 ; <batch-generate-error(|ctx, "Duplicate variable: variable already defined in the GROUP BY clause")> redefinitions-in-modify
              end
         end

  nabl-constraint(|ctx):
    query@NormalizedQuery(_, selectClause, _, Some(GraphPattern(_, edges, _)), _, _, _, _, _, _, _) -> <fail>
    with group-variables := <collect-in-outer-query(?CommonPathExpression(_, _, _, _, _); get-origin-positions-of-variables); concat> query
       ; aggregations := <get-aggregations> query
       ; varRefs-per-aggregation := <map(origin-track-forced(collect-in-outer-query(?VarRef(_, <id>)); !Some(<id>)))> aggregations
       ; varRefs-per-aggregation-when-multiple := <filter(has-multiple-groupVarRefs(|group-variables))> varRefs-per-aggregation
       ; <batch-generate-error(|ctx, "Accessing multiple group variables in a single aggregation is not yet supported")> varRefs-per-aggregation-when-multiple

       ; aggregations-contents := <map(get-exp-from-aggregation)> aggregations
       ; nested-aggregations := <map(get-aggregations); concat>
       ; varRefs-per-nested-aggregation := <map(origin-track-forced(collect-in-outer-query(?VarRef(_, <id>)); !Some(<id>)))> nested-aggregations
       ; varRef-per-nested-aggregation-no-groupVar := <filter(has-no-groupVarRefs(|group-variables))> varRefs-per-nested-aggregation
       ; <batch-generate-error(|ctx, "Nested aggregation not allowed here")> varRef-per-nested-aggregation-no-groupVar

   nabl-constraint(|ctx):
    t@Constraints(_) -> <fail>
    with
      aggregations := <get-aggregations-without-group-variables> t;
      <batch-generate-error(|ctx, "Aggregation without group variables not allowed in WHERE")> aggregations

  nabl-constraint(|ctx):
   t@GroupByClause(_) -> <fail>
    with
      aggregations := <get-aggregations-without-group-variables> t;
      <batch-generate-error(|ctx, "Aggregation without group variables not allowed in GROUP BY")> aggregations

  get-aggregations-without-group-variables = get-aggregations; filter(not(contains-varRef + contains-nested-aggregation))

  contains-varRef = oncetd(?VarRef(_, _))

  contains-nested-aggregation = where (get-exp-from-aggregation; get-aggregations; not(?[]))

  get-origin-positions-of-variables:
    CommonPathExpression(_, Vertices(vertices), Edges(edges), _, _) -> <conc; make-set> (origins-of-vertices, origins-of-edges)
    with origins-of-vertices := <map(?Vertex(_, <id>, _))> vertices
       ; origins-of-edges := <filter(?Edge(_, _, _, _, <id>, _))> edges

  has-multiple-groupVarRefs(|group-variables):
    t@Some(varRefs-in-aggregation) -> t
    where group-varRefs := <isect; not(?[] + ?[_])> (group-variables, varRefs-in-aggregation)

  has-no-groupVarRefs(|group-variables):
    t@Some(varRefs-in-aggregation) -> <id>
    where group-varRefs := <isect; ?[]> (group-variables, varRefs-in-aggregation)

  is-pattern-elem = ?Vertex(_, _, _) + ?Edge(_, _, _, _, _, _)
  get-pattern-elem = ?Vertex(Identifier(<id>, _), _, _) + ?Edge(_, Identifier(<id>, _), _, _, _, _)

  generate-error-on-duplicates(|ctx, message) = ?vars; map(generate-error-on-duplicate(|ctx, vars, message))

  generate-error-on-duplicate(|ctx, vars, message):
    var -> <id>
    with vars' := <filter(?var)> vars
       ; <try(gt; !var; generate-error(|ctx, message))> (<length> vars', 1)

  nabl-constraint(|ctx):
    SelectClause(Star(), ExpAsVars(expAsVars)) -> <fail>
    with group-variables := <filter(get-group-variable-from-select-star)> expAsVars
       ; <map(generate-error(|ctx, $[Cannot select all variables since [<id>] is a group variable but group variables cannot be selected]))> group-variables

  get-group-variable-from-select-star = ?ExpAsVar(VarRef(Identifier(<id>, _)), _, _, _); ?v; origin-text; ?"*"; !v

rules // in-lined constraints

  nabl-constraint(|ctx):
    ReferenceInInlinedConstraint(v) -> <fail>
    with
      <generate-error(|ctx, $['[v]' should be omitted here])> v

  nabl-constraint(|ctx):
    CrossReferenceInInlinedConstraint(v) -> <fail>
    with
      <generate-error(|ctx, $['[v]' is not visible here])> v

rules // vertex in WHERE without rounded brackets

  nabl-constraint(|ctx):
    Vertex(v, _, _) -> <fail>
    where
      <string-ends-with(|<VERTEX_WITHOUT_BRACKETS>)> v
    with
      <generate-error(|ctx, $<Vertices need to be surrounded by brackets: (<<origin-text> v>)>)> v

rules

  nabl-constraint(|ctx):
    NormalizedQuery(_, SelectClause(_, ExpAsVars(select-elems)), _, _, groupClause, havingClause, orderByClause, _, _, _, _) -> <fail>
    where
      None() := groupClause
    ; [] := <get-aggregations> select-elems // there are no aggregations in the SELECT
    with
      aggregations-in-orderByclause := <get-aggregations> orderByClause
    ; <batch-generate-error(|ctx, "Aggregation in ORDER BY only allowed if SELECT has aggregations")> aggregations-in-orderByclause

  // if SELECT DISTINCT then ORDER BY expressions may only be repetitions of expressions in SELECT
  nabl-constraint(|ctx):
    NormalizedQuery(_, SelectClause(Some(Distinct()), ExpAsVars(select-elems)), _, _, _, _, Some(OrderByClause(order-by-elems)), _, _, _, _) -> <fail>
    with
      select-vars := <map(?ExpAsVar(_, Identifier(<id>, _), _, _)); strip-annos> select-elems
    ; order-by-expressions := <map(?OrderByElem(<id>, _, _)); strip-annos> order-by-elems
    ; order-by-expressions-not-in-select := <remove-all(?VarRef(Identifier(<id>, _), _); !(<id>, select-vars); elem)> order-by-expressions
    ; <batch-generate-error(|ctx, "Because of DISTINCT projection, the expression in ORDER BY should be one of the expressions in the SELECT")> order-by-expressions-not-in-select

  nabl-constraint(|ctx):
    e@IllegalNull() -> <fail>
    with
      <generate-error(|ctx, "Use IS NULL or IS NOT NULL")> e

  nabl-constraint(|ctx):
    SelectClause(_, e@Star()) -> <fail>
    with
      <generate-error(|ctx, "SELECT * not allowed in combination with GROUP BY")> e

  nabl-constraint(|ctx):
    SelectClause(_, e@ExpAsVars([])) -> <fail>
    with
      <generate-error(|ctx, "SELECT * not allowed if there are no variables in the graph pattern")> e

  nabl-constraint(|ctx):
    COUNT(Some(Distinct()), e@Star()) -> <fail>
    with
      <generate-error(|ctx, "* not allowed in combination with DISTINCT")> e

rules // subqueries

  nabl-constraint(|ctx):
    q@NormalizedQuery(_, _, _, _, _, _, _, _, _, _, _) -> <fail>
    with scalarSubqueries := <collect(?Exists(_) + ?Subquery(_)); remove-all(?Exists(_))> q
       ; multiColumnScalarSubqueries := <filter(is-multi-column-subquery)> scalarSubqueries
       ; zeroColumnScalarSubqueries := <filter(is-zero-column-subquery)> scalarSubqueries
       ; <batch-generate-error(|ctx, "Scalar subquery is expected to return a single column, but multiple columns were returned")> multiColumnScalarSubqueries
       ; <batch-generate-error(|ctx, "Scalar subquery is expected to return a single column, but zero columns were returned")> zeroColumnScalarSubqueries

  is-multi-column-subquery = ?Subquery(NormalizedQuery(_, SelectClause(_, e@ExpAsVars(expAsVars)), _, _, _, _, _, _, _, _, _))
                           ; where(not( <eq> (<length> expAsVars, 1) )); !e

  is-zero-column-subquery = ?Subquery(NormalizedQuery(_, SelectClause(_, e@ExpAsVars(expAsVars)), _, _, _, _, _, _, _, _, _))
                           ; where( <eq> (<length> expAsVars, 0) ); !e

  nabl-constraint(|ctx):
    Subquery(NormalizedQuery(_, t@selectOrUpdateClause, _, _, _, _, _, _, _, _, _)) -> <fail>
    where not ( <?SelectClause(_, _)> selectOrUpdateClause )
    with <generate-error(|ctx, "SELECT clause expected here")> t

  nabl-constraint(|ctx):
    t@NormalizedQuery(_, _, _, _, _, _, _, _, _, "v1.3", _) -> <fail>
    with nonPgql13Subqueries := <collect(is-non-pgql13-query)> t
       ; <map(get-select-clause); batch-generate-error(|ctx, "Subquery uses older version of PGQL; please make sure that both inner and outer query use PGQL 1.3 syntax")> nonPgql13Subqueries

  nabl-constraint(|ctx):
    t -> <fail>
    where <is-non-pgql13-query> t
    with pgql13Subqueries := <collect(is-pgql13-query)> t
       ; <map(get-select-clause); batch-generate-error(|ctx, "Subquery uses PGQL 1.3 syntax but outer query does not")> pgql13Subqueries

  is-pgql13-query = ?NormalizedQuery(_, _, _, _, _, _, _, _, _, "v1.3", _)

  is-non-pgql13-query = ?NormalizedQuery(_, _, _, _, _, _, _, _, _, version, _); where (!version; not(?"v1.3"))

  get-select-clause = ?NormalizedQuery(_, <id>, _, _, _, _, _, _, _, _, _)

rules // helper rules

  batch-generate-error(|ctx, m) = map(generate-error(|ctx, m))
    
  generate-error(|ctx, m):
    t -> <id>
    with
      failtask := <task-create-fail(|ctx)>
    ; <task-create-error-on-failure(|ctx, failtask, m)> t

  nabl-constraint(|ctx):
    ErrorMessage(term, m) -> <fail>
    where
      <generate-error(|ctx, m)> term

rules // temporary limitation

  nabl-constraint(|ctx):
    ComplexRegularExpressionNotSupported(edgesOrPaths) -> <fail>
    with [_|[secondEdgeOrPath|_]] := edgesOrPaths
       ; <generate-error(|ctx, "Not yet supported: multiple edge patterns in SHORTEST or CHEAPEST")> edgesOrPaths

  nabl-constraint(|ctx):
    ComplexParenthesizedRegularExpressionNotSupported(edges) -> <fail>
    with <generate-error(|ctx, "Not yet supported: multiple edge patterns in SHORTEST or CHEAPEST")> edges

  nabl-constraint(|ctx):
    Path(_, _, _, _, _, _, _, Some(TopK(kValue))) -> <fail>
    where <?"0"> kValue
    with <generate-error(|ctx, "Value should be greater than 0")> kValue

  nabl-constraint(|ctx):
    Path(_, _, pathExpression, quantifier, _, _, goal, _) -> <fail>
    where <?Shortest() + ?Cheapest() + ?Any() + ?All()> goal
        ; <?None() + ?Some(BetweenNAndM("0", "1")); origin-text; ?"?"> quantifier
    with error-term := <?Some(_) <+ !pathExpression; collect-one(?Edge(_, _, _, _, _, _))> quantifier 
       ; if <?All()> goal
         then <generate-error(|ctx, "Quantifier of the form {1,4} expected")> error-term
         else <generate-error(|ctx, "Quantifier of the form * or + or {1,4} expected")> error-term
         end

  nabl-constraint(|ctx):
    Path(_, _, pathExpression, quantifier, _, _, goal, _) -> <fail>
    where <?All()> goal
        ; <?Some(BetweenNAndM(_, "-1"))> quantifier
    with <generate-error(|ctx, "Path finding goal ALL requires an upper bound on the path length")> quantifier

  nabl-constraint(|ctx):
    t@CommonPathExpression(_, _, connections, _, _) -> <fail>
    where <collect-in-outer-query(?Path(_, _, _, _, _, _, _, _)); not(?[])> connections
    with <generate-error(|ctx, "Nested regular expressions not supported")> t

  nabl-constraint(|ctx):
    t@LabelDisjunction(_, _) -> <fail>
    with <generate-error(|ctx, "Label disjunction not supported here")> t

rules // CHEAPEST

  nabl-constraint(|ctx):
    t@Path(_, _, CommonPathExpression(_, _, _, Constraints(constraints), costClause), _, _, _, Cheapest(), _) -> <fail>
    where <?None()> costClause
    with if <?[]> constraints
    then <generate-error(|ctx, "COST clause expected after pattern")> t
    else <?[<id>]; generate-error(|ctx, "COST clause expected after WHERE clause")> constraints
    end

  nabl-constraint(|ctx):
    t@Path(_, _, CommonPathExpression(_, vertices, edges, _, Some(CostClause(costExpression))), _, _, _, Cheapest(), _) -> <fail>
    where <?Vertices([Vertex(v1, _, _), Vertex(v2, _, _)])> vertices
        ; <?Edges([Edge(_, e, _, _, _, _)])> edges
    with variablesDefs := [v1, v2, e]
       ; <generate-error-on-cross-constraint(|ctx, variablesDefs)> costExpression

  generate-error-on-cross-constraint(|ctx, variablesDefs):
    t@And(lhs, rhs) -> t
    with <generate-error-on-cross-constraint(|ctx, variablesDefs)> lhs
       ; <generate-error-on-cross-constraint(|ctx, variablesDefs)> rhs

  generate-error-on-cross-constraint(|ctx, variablesDefs):
    t -> t
    where <not(?And(_, _))> t
    with variables := <collect(?VarRef(<id>, _) + ?Vertex(<id>, _, _) + ?Edge(_, <id>, _, _, _, _) + ?Path(_, _, _, _, <id>, _, _, _))> t
       ; variableRefs := <strip-annos; isect> (variablesDefs, variables)
       ; <try(!(<length> variableRefs, 1); gt; !t; generate-error(|ctx, "Not yet supported: expressions with multiple variables"))> t

  nabl-constraint(|ctx):
    Path(_, _, CommonPathExpression(_, _, _, _, Some(t@CostClause(_))), _, _, _, pathFindingGoal, _) -> <fail>
    where not ( <?Cheapest()> pathFindingGoal )
    with <generate-error(|ctx, "COST clause only allowed in combination with CHEAPEST")> t

rules // literals

  external is-valid-datetime(|)

  nabl-constraint(|ctx):
    datetime-> <fail>
    where <(?Date(_) + ?Time(_) + ?Timestamp(_)); is-valid-datetime; ?ErrorMessage(_, m)> datetime
    with <generate-error(|ctx, m)> datetime

  nabl-constraint(|ctx):
    t@NormalizedQuery(_, _, _, _, _, _, _, _, _, pgqlVersion, _) -> <fail>
    where not ( <?"v1.0" + ?"v1.1"> pgqlVersion )
    with <alltd-in-outer-query(check-illegal-java-escaping(|ctx))> t

  check-illegal-java-escaping(|ctx):
    t@String(s) -> <fail>
    where <is-substring(!"\\'")> s
    with <generate-error(|ctx, "Use '' instead of \\' to escape a single quote")> t

  check-illegal-java-escaping(|ctx):
    t@Identifier(identifier, _) -> <fail>
    where <is-substring(!"\\\"")> identifier
    with <generate-error(|ctx, "Use \"\" instead of \\\" to escape a double quote")> t

rules // IN

  nabl-constraint(|ctx) = ?AstPlusMetadata(_, metadata); alltd(check-inPredicate(|ctx, metadata))

  check-inPredicate(|ctx, metadata):
    inPredicate@InPredicate(exp, Array(valueExpressions)) -> <fail>
    with [x|xs] := <map(try(add-default-literal-type))> valueExpressions

         // check that type of expression on left-hand of IN is compatible with expression of list elements
       ; if <?ExpressionPlusType(_, Type(t1)); !t1; not(same-type(|x, metadata))> exp
         then ExpressionPlusType(_, Type(t2)) := x
            ; <generate-error(|ctx, $[The IN predicate is undefined for left-hand operand type [t1] and list value types [t2]])> inPredicate
         end

         // check that values in the list are of compatible type
       ; <remove-all(same-type(|x, metadata)); batch-generate-error(|ctx, $[[<!x; ?ExpressionPlusType(_, Type(<id>))>] expected here])> xs

  same-type(|x, metadata):
    ExpressionPlusType(_, type1) -> <id>
    where ExpressionPlusType(_, type2) := x
        ; <eq <+ get-union-type(|metadata)> (type1, type2)

rules // SELECT

  nabl-constraint(|ctx):
    NormalizedQuery(_, t@SelectClause(_, _), _, None(), _, _, _, _, _, _, _) -> <fail>
    with <generate-error(|ctx, "SELECT query without FROM clause not supported")> t

rules // MODIFY

  // e.g. UPDATE x.prop = 123 ... GROUP BY x.prop
  nabl-constraint(|ctx):
    SetProperty(t@VarRef(_, _), _) -> <fail>
    with <generate-error(|ctx, "Cannot set a property that is grouped by")> t

  // setting a property twice, in either UPDATE or INSERT
  nabl-constraint(|ctx):
    properties -> <fail>
    where <?SetProperties(setPropertyExps) + ?Properties(setPropertyExps)> properties
    with propertyRefs := <filter(?SetProperty(PropRef(_, Identifier(<id>, _)), _))> setPropertyExps
       ; duplicatePropertyRefs := <filter(is-elem-contained-more-than-once(|propertyRefs))> propertyRefs
       ; <batch-generate-error(|ctx, "Property is set multiple times")> duplicatePropertyRefs

  is-elem-contained-more-than-once(|elems):
    elem -> <id>
    where duplicates := <filter(?elem)> elems
        ; <gt> (<length>, 1)

  nabl-constraint(|ctx):
    UpdateClause(updates) -> <fail>
    with updateElements := <filter(?Update(VarRef(Identifier(<id>, _), _), _))> updates
       ; duplicateUpdateElements := <filter(is-elem-contained-more-than-once(|updateElements))> updateElements
       ; <batch-generate-error(|ctx, "Element is updated multiple times (merge the two updates together)")> duplicateUpdateElements

  nabl-constraint(|ctx):
    DeleteClause(deletions) -> <fail>
    with deleteElements := <filter(?VarRef(Identifier(<id>, _), _))> deletions
       ; duplicateDeleteElements := <filter(is-elem-contained-more-than-once(|deleteElements))> deleteElements
       ; <batch-generate-error(|ctx, "Element is deleted multiple times")> duplicateDeleteElements

  nabl-constraint(|ctx):
    t -> <fail>
    where <?VertexInsertion(Identifier(v, originText), _, _, Some(Properties(setProperties))) +
           ?DirectedEdgeInsertion(Identifier(v, originText), _, _, _, _, Some(Properties(setProperties))) +
           ?Update(VarRef(Identifier(v, originText), _), SetProperties(setProperties))> t
    with v' := <strip-annos> v
       ; otherVariablesThanV := <filter(?SetProperty(ExpressionPlusType(PropRef(VarRef(Identifier(<id>, _), _), _), _), _); strip-annos; not(?v'))> setProperties
       ; if <eq> (v', <strip-annos> originText)
         then varNameAsString := <origin-text> v
         else varNameAsString := originText // using <origin-text> like above fails SPT tests, thus we avoid using it for unquoted identifier so that we at least can still use unquoted identifiers in INSERT/UPDATE queries in SPT
         end
       ; <batch-generate-error(|ctx, $<Did you mean <varNameAsString>?>)> otherVariablesThanV

  nabl-constraint(|ctx):
    ModifyClause(insertUpdateDeleteClauses) -> <fail>
    with additionalInsertClauses := <filter(?InsertClause(_, _)); try(Tl)> insertUpdateDeleteClauses
       ; additionalUpdateClauses := <filter(?UpdateClause(_)); try(Tl)> insertUpdateDeleteClauses
       ; additionalDeleteClauses := <filter(?DeleteClause(_)); try(Tl)> insertUpdateDeleteClauses
       ; <batch-generate-error(|ctx, "Only a single INSERT clause is allowed per query; use commas to insert multiple elements in a single INSERT clause")> additionalInsertClauses
       ; <batch-generate-error(|ctx, "Only a single UPDATE clause is allowed per query; use commas to update multiple elements in a single UPDATE clause")> additionalUpdateClauses
       ; <batch-generate-error(|ctx, "Only a single DELETE clause is allowed per query; use commas to delete multiple elements in a single DELETE clause")> additionalDeleteClauses

// CREATE PROPERTY GRAPH

  nabl-constraint(|ctx):
    CreatePropertyGraph(_, VertexTables(vertexTables), EdgeTables(edgeTables), _) -> <fail>
    with vertexTableNames := <map(?VertexTable(_, <id>, _, _); to-identifier-without-origin-info)> vertexTables
       ; <generate-error-on-duplicates(|ctx, "Duplicate vertex table name; use an alias to make the vertex table name unique (table AS alias)")> vertexTableNames
       ; edgeTableNames := <map(?EdgeTable(_, <id>, _, _, _, _); to-identifier-without-origin-info)> edgeTables
       ; <generate-error-on-duplicates(|ctx, "Duplicate edge table name; use an alias to make the edge table name unique (table AS alias)")> edgeTableNames
       ; vertexTableReferences := <collect((?SourceVertexTable(_, Name(_, <id>)) + ?DestinationVertexTable(_, Name(_, <id>))); to-identifier-without-origin-info)> edgeTables
       ; unresolvedVertexTableReferences := <diff> (vertexTableReferences, vertexTableNames)
       ; <batch-generate-error(|ctx, "Undefined vertex table")> unresolvedVertexTableReferences

  to-identifier-without-origin-info = origin-track-forced(?Identifier(localName, _); !localName)

  nabl-constraint(|ctx):
    PropertyExpressions(expAsVars) -> <fail>
    with expAsVarsWithComplexExpressions := <remove-all(?ExpAsVar(VarRef(Identifier(_, _)), _) + ?ExpAsVar(Cast(VarRef(Identifier(_, _)), _), _))> expAsVars
       ; <batch-generate-error(|ctx, "Only column references and simple CAST expressions allowed; arbitrary expressions are not yet supported")> expAsVarsWithComplexExpressions
       ; columnRenames := <filter(get-column-rename)> expAsVars
       ; <batch-generate-error(|ctx, "Property name and column name should be the same; renaming is not yet supported")> columnRenames
       ; complexExpressionsWithoutAlias := <remove-all(?ExpAsVar(VarRef(_), _) + ?ExpAsVar(_, Identifier(_, _)))> expAsVars
       ; <batch-generate-error(|ctx, "Alias required (.. AS name)")> complexExpressionsWithoutAlias

  get-column-rename:
    ExpAsVar(Cast(VarRef(Identifier(columnName, _)), _), Identifier(propertyName, _)) -> propertyName
    where <not(eq)> (columnName, propertyName)

  nabl-constraint(|ctx):
    t -> <fail>
    where <?SourceVertexTable(_, Name(Some(schemaName), _)) + ?DestinationVertexTable(_, Name(Some(schemaName), _))> t
    with <generate-error(|ctx, "Schema name not allowed here")> schemaName

// LISTAGG

  nabl-constraint(|ctx):
    LISTAGG(_, _, Some(Separator(separator))) -> <fail>
    where not ( <?String(_)> separator )
    with <generate-error(|ctx, "Only string literals are allowed as separator")> separator

// schema

  nabl-constraint(|ctx) = ?AstPlusMetadata(_, metadata); alltd(check-labels(|ctx, metadata))

  check-labels(|ctx, metadata):
    query@NormalizedQuery(_, _, _, Some(GraphPattern(Vertices(vertices), edgesAndPaths, Constraints(constraints))), _, _, _, _, _, _, _) -> <fail>
    with vertexDefinititions := <map(?Vertex(_, <id>, _))> vertices
       ; edgeDefinititions := <filter(?Edge(_, _, _, _, <id>, _))> edgesAndPaths
       ; vertexLabels := <get-vertex-labels(|metadata)>
       ; if <not(?None())> vertexLabels
         then unresolvedVertexLabels := <collect(get-unresolved-label(|vertexDefinititions, vertexLabels))> query
            ; <batch-generate-error(|ctx, "Vertex label does not exist")> unresolvedVertexLabels
         end
       ; edgeLabels := <get-edge-labels(|metadata)>
       ; if <not(?None())> edgeLabels
         then unresolvedEdgeLabels := <collect(get-unresolved-label(|edgeDefinititions, edgeLabels))> query
            ; <batch-generate-error(|ctx, "Edge label does not exist")> unresolvedEdgeLabels
         end

  get-unresolved-label(|varDefinitionOriginPositions, labels):
    FunctionCall(None(), "has_label", [ ExpressionPlusType(VarRef(_, originPosition), _), Identifier(labelReference, _) ]) -> labelReference
    where <elem> (originPosition, varDefinitionOriginPositions)
        ; <not(elem)> (labelReference, labels)

  nabl-constraint(|ctx):
    ExpressionPlusType(PropRef(_, Identifier(propName, _)), Undefined()) -> <fail>
    with <generate-error(|ctx, $[Property does not exist for any of the labels])> propName

  nabl-constraint(|ctx):
    ExpressionPlusType(PropRef(_, Identifier(propName, _)), AmbiguousType()) -> <fail>
    with <generate-error(|ctx, $[Property has incompatible data types in different labels])> propName

  nabl-constraint(|ctx):
    ExpressionPlusType(e@UMin(ExpressionPlusType(_, Type(t))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator - (unary minus) is undefined for the argument type [t]])> e

  nabl-constraint(|ctx):
    e@Not(ExpressionPlusType(_, Type(t))) -> <fail>
    where not ( <?"BOOLEAN" + ?UnknownType()> t )
    with <generate-error(|ctx, $[The operator NOT is undefined for the argument type [t]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@And(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator AND is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Or(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator OR is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Mul(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator * is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Add(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator + is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Div(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator / is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Mod(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator % is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Sub(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator - is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Eq(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator = is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Neq(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator <> (or !=) is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Gt(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator > is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Lt(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator < is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Gte(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator >= is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Lte(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator <= is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(e@Cct(ExpressionPlusType(_, Type(t1)), ExpressionPlusType(_, Type(t2))), Undefined()) -> <fail>
    with <generate-error(|ctx, $[The operator || is undefined for the argument types [t1], [t2]])> e

  nabl-constraint(|ctx):
    ExpressionPlusType(aggregation, Undefined()) -> <fail>
    where <?SUM(_, ExpressionPlusType(_, Type(t))) +
           ?MIN(_, ExpressionPlusType(_, Type(t))) +
           ?MAX(_, ExpressionPlusType(_, Type(t))) +
           ?AVG(_, ExpressionPlusType(_, Type(t))) +
           ?ARRAY-AGG(_, ExpressionPlusType(_, Type(t))) +
           ?LISTAGG(_, ExpressionPlusType(_, Type(t)), _)> aggregation
    with operation := <get-constructor; try(?"ARRAY-AGG"; !"ARRAY_AGG")> aggregation
       ; <generate-error(|ctx, $[The aggregate [operation] is undefined for the argument type [t]])> aggregation

  // check that WHERE clauses contains boolean expressions
  nabl-constraint(|ctx):
    Constraints(constraints) -> <fail>
    with <remove-all(?ExpressionPlusType(<id>, Type("BOOLEAN")) + ?ExpressionPlusType(<id>, UnknownType()))
                    ; batch-generate-error(|ctx, "WHERE clause expects a BOOLEAN expression")> constraints

  // check that HAVING clauses contains boolean expressions
  nabl-constraint(|ctx):
    HavingClause(ExpressionPlusType(exp, Type(t))) -> <fail>
    where <not(?"BOOLEAN" + ?UnknownType())> t
    with <generate-error(|ctx, "HAVING clause expects a BOOLEAN expression")> exp

  // check that ORDER BY does not contain vertex/edge/array terms
  nabl-constraint(|ctx):    
    OrderByElem(ExpressionPlusType(exp, Type(t)), _, version) -> <fail>
    where <not(?"v1.0")> version
        ; <?"VERTEX" + ?"EDGE" + ?"ARRAY"> t
    with <generate-error(|ctx, $[Cannot order by [t]])> exp
