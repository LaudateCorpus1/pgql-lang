module type-analysis

imports

  stratego/-
  libspoofax/properties/-
  libspoofax/nabl/-
  libspoofax/task/-
  libspoofax/types/-
  signatures/-
  normalized-signatures
  common

rules

  add-types = ?AstPlusMetadata(ast, metadata); !ast; add-types-to-query(|metadata, []); !AstPlusMetadata(<id>, metadata)

  add-types-to-query(|metadata, variablesWithTypes):
      NormalizedQuery(CommonPathExpressions(pathExpressions), selectOrModifyClause, optionalGraphName, graphPattern, groupBy, having, orderBy, limitOffsets, error-messages, version, bindVariableCount) ->
        NormalizedQuery(CommonPathExpressions(pathExpressions), selectOrModifyClause, optionalGraphName, graphPattern', groupBy, having, orderBy, limitOffsets, error-messages, version, bindVariableCount)
    with if <?Some(GraphPattern(Vertices(vertices), connections, _))> := graphPattern
         then verticesWithTypes := <collect-in-outer-query(?Vertex(_, <id>, _); !VariablePlusType(<id>, Type("VERTEX")))> (vertices, connections)
            ; edgesWithTypes := <collect-in-outer-query(?Edge(_, _, _, _, <id>, _); !VariablePlusType(<id>, Type("EDGE")))> connections
            ; variablesWithTypes' := <conc> (variablesWithTypes, verticesWithTypes, edgesWithTypes)
            ; constraints := <collect-in-outer-query(?Constraints(<id>)); concat> graphPattern
            ; graphPattern' := <alltd(add-type(|metadata, variablesWithTypes', constraints))> graphPattern
         else variablesWithTypes' := variablesWithTypes
            ; graphPattern' := graphPattern
         end

rules // variable references

  add-type(|metadata, variablesWithTypes, constraints):
    exp@VarRef(_, varRefOriginPosition) -> ExpressionPlusType(exp, type)
    with type := <fetch-elem(?VariablePlusType(varRefOriginPosition, <id>)) <+ !UnknownType()> variablesWithTypes

rules // property references

  add-type(|metadata, variablesWithTypes, constraints):
    exp@PropRef(VarRef(_, varRefOriginPosition), Identifier(propName, _)) -> ExpressionPlusType(exp, propType)
    with elementType := <fetch-elem(?VariablePlusType(varRefOriginPosition, <id>)) <+ !UnknownType()> variablesWithTypes
       ; labelExpression := <filter(simplify-label-expression(|varRefOriginPosition)); (?[]; !All() <+ to-label-conjunction)> constraints
       ; propType := <get-property-type-from-label-expression(|elementType, propName, metadata)> labelExpression

  simplify-label-expression(|varRefOriginPosition):
    FunctionCall(None(), "has_label", [ VarRef(_, varRefOriginPosition), Identifier(label, _)]) -> label

  simplify-label-expression(|varRefOriginPosition):
    Or(a, b) -> LabelOr(a', b')
    where a' := <simplify-label-expression(|varRefOriginPosition)> a
        ; b' := <simplify-label-expression(|varRefOriginPosition)> b

  to-label-conjunction = reverse; !(<Tl>, <Hd>); foldl(to-label-AND)
  to-label-AND = ?(exp1, exp2); !LabelAnd(exp1, exp2)

  get-property-type-from-label-expression(|elementType, propName, metadata):
    labelExpression -> type
    where <is-string> labelExpression
    with labelReference := labelExpression
       ; if <?Type("VERTEX")> elementType
         then type := <get-vertex-property-type(|metadata)> (labelReference, propName)
         else type := <get-edge-property-type(|metadata)> (labelReference, propName)
         end

  get-property-type-from-label-expression(|elementType, propName, metadata):
    LabelAnd(a, b) -> result
    with result := <compute-union-type(|elementType, propName, metadata)> (a, b)

  get-property-type-from-label-expression(|elementType, propName, metadata):
    LabelOr(a, b) -> result
    with result := <compute-union-type(|elementType, propName, metadata)> (a, b)

  compute-union-type(|elementType, propName, metadata):
    (labelA, labelB) -> result
    with typeA := <get-property-type-from-label-expression(|elementType, propName, metadata)> labelA
       ; typeB := <get-property-type-from-label-expression(|elementType, propName, metadata)> labelB
       ; result := <get-union-type(|metadata)> (typeA, typeB)

  get-property-type-from-label-expression(|elementType, propName, metadata):
    All() -> result
    with labels := <?Type("VERTEX"); get-vertex-labels(|metadata) <+ get-edge-labels(|metadata)> elementType
       ; if <?None()> labels
         then result := UnknownType()
         else types := <map(!(<id>, propName); get-vertex-property-type(|metadata))> labels
            ; result := <foldl(get-union-type(|metadata))> (types, Undefined())
         end

rules // functions

  add-type(|metadata, variablesWithTypes, constraints) = FunctionCall(?None(), ?"has_label", [ add-type(|metadata, variablesWithTypes, constraints), ?Identifier(_, _)]); !ExpressionPlusType(<id>, Type("BOOLEAN"))

rules // binary expressions

  add-type(|metadata, variablesWithTypes, constraints) =
    ( 
      ?And(_, _) + ?Or(_, _) +
      ?Eq(_, _) + ?Neq(_, _) + ?Gt(_, _) + ?Lt(_, _) + ?Gte(_, _) + ?Lte(_, _) +
      ?Mul(_, _) + ?Add(_, _) + ?Div(_, _) + ?Mod(_, _) + ?Sub(_, _) +
      ?Cct(_, _)
    )
    ; add-value-type-to-binary-operation(|metadata, variablesWithTypes, constraints)

  add-value-type-to-binary-operation(|metadata, variablesWithTypes, constraints):
    exp -> ExpressionPlusType(exp', type)
    with operation := <get-constructor> exp
       ; args@[ExpressionPlusType(_, type1), ExpressionPlusType(_, type2)] := <get-arguments; alltd(add-type(|metadata, variablesWithTypes, constraints))> exp
       ; if <?AmbiguousType()> type1 + <?AmbiguousType()> type2
         then type := UnknownType()
         else if <?Type(t1)> type1;  <?Type(t2)> type2
              then type := <get-operation-return-type(|metadata)> (operation, t1, t2)
              else type := <?Type(_) <+ !type2; ?Type(_) <+ !UnknownType()> type1
              end
         end
       ; exp' := <origin-track-forced(!(operation, args); mkterm)> exp



//  add-type:
//    SetProperty(propRef, exp) -> SetProperty(propRef, <alltd(add-type)> exp) // this assures we skip adding a type to the propRef of a SET clause

//  add-value-type(|metadata):
//    exp@PropRef(_, Identifier(propName, _), elementType, labelExpression) -> ExpressionPlusType(exp, type)
//    with type := <get-property-type-from-label-expression(|elementType, propName)> labelExpression


  add-value-type(|metadata) =
    (
      ?InPredicate(_, _, _) +
      ?Exists(_) +
      ?IsNull(_)
    )
    ; !ExpressionPlusType(<id>, Type("BOOLEAN"))

  add-value-type(|metadata):
    t@UMin(ExpressionPlusType(exp, type)) -> ExpressionPlusType(t, type')
    with type' := <?Type(<id>); !("UMin", <id>); get-operation-return-type(|metadata) <+ !UnknownType()> type

  add-value-type(|metadata) = ?Not(_); !ExpressionPlusType(<id>, UnknownType())

  add-value-type(|metadata) = ?COUNT(_, _); !ExpressionPlusType(<id>, <get-long-integer-type(|metadata)>)

  add-value-type(|metadata):
    aggregation -> ExpressionPlusType(aggregation, type')
    where <?SUM(_, ExpressionPlusType(_, type)) +
           ?MIN(_, ExpressionPlusType(_, type)) +
           ?MAX(_, ExpressionPlusType(_, type)) +
           ?AVG(_, ExpressionPlusType(_, type)) +
           ?ARRAY-AGG(_, ExpressionPlusType(_, type)) +
           ?LISTAGG(_, ExpressionPlusType(_, type), _)> aggregation
    with operation := <get-constructor> aggregation
       ; type' := <?Type(<id>); !(operation, <id>); get-operation-return-type(|metadata) <+ !UnknownType()> type

  add-value-type(|metadata) = ?BindVariable(_); !ExpressionPlusType(<id>, UnknownType())

  add-value-type(|metadata) = ?Null(); !ExpressionPlusType(<id>, UnknownType())
  add-value-type(|metadata) = (?True() + ?False()); !ExpressionPlusType(<id>, Type("BOOLEAN"))
  add-value-type(|metadata) = ?Integer(_); !ExpressionPlusType(<id>, <get-long-integer-type(|metadata)>)
  add-value-type(|metadata) = ?Decimal(_); !ExpressionPlusType(<id>, <get-decimal-literal-type(|metadata)>)
  add-value-type(|metadata) = ?String(_); !ExpressionPlusType(<id>, <get-string-literal-type(|metadata)>)
  add-value-type(|metadata) = ?Date(_); !ExpressionPlusType(<id>, Type("DATE"))
  add-value-type(|metadata) = ?Time(_); !ExpressionPlusType(<id>, Type(<has-timezone; !"TIME WITH TIME ZONE" <+ !"TIME">))
  add-value-type(|metadata) = ?Timestamp(_); !ExpressionPlusType(<id>, Type(<has-timezone; !"TIMESTAMP WITH TIME ZONE" <+ !"TIMESTAMP">))
  external has-timezone(|)

  add-default-literal-type:
    ExpressionPlusType(exp, UnknownType()) -> ExpressionPlusType(exp, Type(t))
    where t := <is-numeric-literal; !"NUMBER" +
                is-boolean-literal; !"BOOLEAN" +
                ?String(_); !"STRING" +
                ?Date(_); !"DATE" +
                ?Time(_); !"TIME" +
                ?Timestamp(_); !"TIMESTAMP"
                > exp

  add-value-type(|metadata) = ?Cast(_, type); !ExpressionPlusType(<id>, Type(type))

  add-value-type(|metadata) = ?CharacterSubstring(_, _, _); !ExpressionPlusType(<id>, <get-string-literal-type(|metadata)>)

  add-value-type(|metadata):
    exp@ScalarSubquery(Subquery(NormalizedQuery(_, SelectClause(_, ExpAsVars(expsAsVars)), _, _, _, _, _, _, _, _, _))) -> ExpressionPlusType(exp, type)
    with if <?[ExpAsVar(ExpressionPlusType(_, Type(t)), _, _, _)]> expsAsVars
         then type := Type(t)
         else type := UnknownType()
         end

  add-value-type(|metadata) = ?FunctionCall(_, _, _); !ExpressionPlusType(<id>, UnknownType())

//  get-vertex-labels(|metadata) = !None()
//  get-edge-labels(|metadata) = !None()
//
//  get-vertex-property-type(|metadata) = !UnknownType()
//  get-edge-property-type(|metadata) = !UnknownType()

//  get-string-literal-type(|metadata) = !UnknownType()
//  get-long-integer-type(|metadata) = !UnknownType()
//  get-short-integer-type(|metadata) = !UnknownType()
//  get-decimal-literal-type(|metadata) = !UnknownType()

//  get-operation-return-type(|metadata) = !UnknownType()
//  get-union-type(|metadata) = !UnknownType()

  get-string-literal-type(|metadata) = !Type("STRING")
  get-short-integer-type(|metadata) = !Type("INTEGER")
  get-long-integer-type(|metadata) = !Type("LONG")
  get-decimal-literal-type(|metadata) = !Type("DOUBLE")

  get-count-aggregate-type(|metadata) = !Type("LONG")

  get-operation-return-type(|metadata) = ?("UMin", "INTEGER"); !Type("INTEGER")

  get-operation-return-type(|metadata) = ?("Cct", "STRING", "STRING"); !Type("STRING")

  get-operation-return-type(|metadata) = ?("Cct", "STRING", "STRING"); !Type("STRING")
  get-operation-return-type(|metadata) = ?("Add", "INTEGER", "INTEGER"); !Type("INTEGER")

  get-operation-return-type(|metadata) = ?("MIN", "STRING"); !Type("STRING")
  get-operation-return-type(|metadata) = ?("SUM", "INTEGER"); !Type("LONG")

  get-operation-return-type(|metadata) = !UnknownType() // !Undefined()

  get-vertex-labels(|metadata) = !["PERSON", "COMPANY"]

  get-edge-labels(|metadata) = !["KNOWS"]

  get-vertex-property-type(|metadata) = ?("PERSON", "FIRSTNAME"); !Type("STRING")
  get-vertex-property-type(|metadata) = ?("PERSON", "AGE"); !Type("INTEGER")
  get-vertex-property-type(|metadata) = ?("COMPANY", "AGE"); !Type("DATE")

  get-edge-property-type(|metadata) = ?("KNOWS", "SINCE"); !Type("DATE")

  get-vertex-property-type(|metadata) = !Undefined()

  get-edge-property-type(|metadata) = !Undefined()

  get-union-type(|metadata) = ?(Undefined(), <id>) + ?(<id>, Undefined())
  get-union-type(|metadata) = (?(AmbiguousType(), _) + ?(_, AmbiguousType())); !AmbiguousType()

  get-union-type(|metadata) = ?(Type("STRING"), Type("STRING")); !Type("STRING")

  get-union-type(|metadata) = ?(Type("INTEGER"), Type("INTEGER")); !Type("INTEGER")

  get-union-type(|metadata) = ?(Type("INTEGER"), Type("DATE"));  !AmbiguousType()
  get-union-type(|metadata) = ?(Type("DATE"), Type("INTEGER"));  !AmbiguousType()
